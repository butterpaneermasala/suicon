<!DOCTYPE html>
<html>
<head>
    <title>Museum FPS Duel</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.4/socket.io.js"></script>
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 4px black;
            z-index: 100;
        }
        #healthBar {
            position: absolute;
            top: 60px;
            left: 20px;
            width: 200px;
            height: 20px;
            background-color: rgba(0,0,0,0.5);
            border: 2px solid white;
            z-index: 100;
        }
        #healthFill {
            height: 100%;
            width: 100%;
            background-color: #00ff00;
            transition: width 0.3s;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 48px;
            text-shadow: 2px 2px 4px black;
            z-index: 100;
            display: none;
            text-align: center;
        }
        #restartBtn {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-shadow: 2px 2px 4px black;
            z-index: 100;
            text-align: center;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="ui">
        Players: <span id="playerCount">1</span>
    </div>
    <div id="healthBar">
        <div id="healthFill"></div>
    </div>
    <div id="gameOver"></div>
    <div id="instructions">
        <h1>MUSEUM SHOOTOUT</h1>
        <p>Click to lock cursor. WASD to move. Mouse to look. SHIFT to sprint. Left click to shoot.</p>
    </div>
    <canvas id="renderCanvas"></canvas>
    
    <script>
        // Game variables
        let playerId;
        let players = {};
        let bullets = {};
        let socket;
        let scene;
        let engine;
        let camera;
        let myPlayer;
        let isGameOver = false;
        
        // Connect to server
        function connectToServer() {
            socket = io('http://localhost:3000');
            
            socket.on('init', (data) => {
                playerId = data.playerId;
                players = data.players;
                bullets = data.bullets;
                initGame();
            });
            
            socket.on('playerConnected', (playerData) => {
                players[playerData.id] = playerData;
                createPlayerModel(playerData.id, playerData);
                updatePlayerCount();
            });
            
            socket.on('playerMoved', (data) => {
                if (players[data.id] && players[data.id].mesh) {
                    players[data.id].mesh.position = new BABYLON.Vector3(data.x, data.y, data.z);
                    players[data.id].mesh.rotation.y = data.rotation;
                    
                    // Update health bar position
                    if (players[data.id].healthBar) {
                        players[data.id].healthBar.position = new BABYLON.Vector3(data.x, data.y + 2, data.z);
                    }
                }
            });
            
            socket.on('bulletFired', (bulletData) => {
                bullets[bulletData.id] = bulletData;
                createBullet(bulletData);
            });
            
            socket.on('bulletRemoved', (bulletId) => {
                if (bullets[bulletId] && bullets[bulletId].mesh) {
                    bullets[bulletId].mesh.dispose();
                    delete bullets[bulletId];
                }
            });
            
            socket.on('playerHit', (data) => {
                if (players[data.playerId]) {
                    players[data.playerId].health = data.health;
                    
                    if (data.playerId === playerId) {
                        updateHealthDisplay();
                    }
                    
                    if (players[data.playerId].healthBarMat) {
                        updatePlayerHealthBar(data.playerId);
                    }
                }
            });
            
            socket.on('playerDied', (id) => {
                if (players[id] && players[id].mesh) {
                    players[id].mesh.dispose();
                    if (players[id].healthBar) {
                        players[id].healthBar.dispose();
                    }
                    delete players[id];
                    updatePlayerCount();
                }
            });
            
            socket.on('gameOver', (winnerId) => {
                isGameOver = true;
                const gameOverDiv = document.getElementById('gameOver');
                gameOverDiv.style.display = 'block';
                gameOverDiv.innerHTML = winnerId === playerId ? 
                    "YOU WIN!<br><button id='restartBtn'>Play Again</button>" : 
                    "YOU LOSE!<br><button id='restartBtn'>Play Again</button>";
                
                document.getElementById('restartBtn').addEventListener('click', restartGame);
            });
            
            socket.on('playerDisconnected', (id) => {
                if (players[id] && players[id].mesh) {
                    players[id].mesh.dispose();
                    if (players[id].healthBar) {
                        players[id].healthBar.dispose();
                    }
                    delete players[id];
                    updatePlayerCount();
                }
            });
        }
        
        function updatePlayerCount() {
            document.getElementById('playerCount').textContent = Object.keys(players).length;
        }
        
        function updateHealthDisplay() {
            const healthPercent = (players[playerId].health / 100) * 100;
            document.getElementById('healthFill').style.width = `${healthPercent}%`;
            
            // Change color based on health
            const healthFill = document.getElementById('healthFill');
            if (healthPercent > 60) {
                healthFill.style.backgroundColor = '#00ff00'; // Green
            } else if (healthPercent > 30) {
                healthFill.style.backgroundColor = '#ffff00'; // Yellow
            } else {
                healthFill.style.backgroundColor = '#ff0000'; // Red
            }
        }
        
        function updatePlayerHealthBar(id) {
            if (players[id] && players[id].healthBarMat) {
                const healthPercent = players[id].health / 100;
                players[id].healthBarMat.emissiveColor = new BABYLON.Color3(
                    1 - healthPercent,
                    healthPercent,
                    0
                );
                players[id].healthBar.scaling.x = healthPercent;
            }
        }
        
        function restartGame() {
            // Reload the page to restart
            location.reload();
        }
        
        // Initialize Babylon.js game
        function initGame() {
            const canvas = document.getElementById("renderCanvas");
            engine = new BABYLON.Engine(canvas, true);
            
            // Create scene
            scene = new BABYLON.Scene(engine);
            scene.gravity = new BABYLON.Vector3(0, -0.98, 0);
            scene.collisionsEnabled = true;
            
            // Set up PS2-style rendering
            scene.clearColor = new BABYLON.Color4(0, 0, 0, 1);
            scene.ambientColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            
            // Low resolution effect
            const pipeline = new BABYLON.DefaultRenderingPipeline("defaultPipeline", false, scene);
            if (pipeline.imageProcessing) {
                pipeline.imageProcessing.contrast = 1.2;
                pipeline.imageProcessing.exposure = 0.8;
            }
            
            // Camera - FPS style
            camera = new BABYLON.FreeCamera("camera", new BABYLON.Vector3(0, 1.8, 0), scene);
            camera.attachControl(canvas, true);
            camera.minZ = 0.1;
            camera.speed = 0.2;
            camera.angularSensibility = 800;
            camera.applyGravity = true;
            camera.checkCollisions = true;
            camera.ellipsoid = new BABYLON.Vector3(0.5, 0.9, 0.5);
            camera.ellipsoidOffset = new BABYLON.Vector3(0, 0.9, 0);
            
            // Set WASD keys explicitly
            camera.keysUp = [87];    // W
            camera.keysDown = [83];  // S
            camera.keysLeft = [65];  // A
            camera.keysRight = [68]; // D
            
            // Create the museum environment
            createMuseum(scene);
            
            // Create my player
            myPlayer = players[playerId];
            createPlayerModel(playerId, myPlayer);
            
            // Create other players
            for (const id in players) {
                if (id !== playerId) {
                    createPlayerModel(id, players[id]);
                }
            }
            
            // Create existing bullets
            for (const id in bullets) {
                createBullet(bullets[id]);
            }
            
            // Weapon
            createWeapon();
            
            // Pointer lock
            canvas.requestPointerLock = canvas.requestPointerLock || 
                                     canvas.mozRequestPointerLock || 
                                     canvas.webkitRequestPointerLock;
            canvas.onclick = function() {
                if (!isGameOver) {
                    canvas.requestPointerLock();
                }
            };
            
            // Initialize health display
            updateHealthDisplay();
            
            // Game loop
            engine.runRenderLoop(function() {
                if (myPlayer && !isGameOver) {
                    // Update my player position
                    myPlayer.x = camera.position.x;
                    myPlayer.y = camera.position.y;
                    myPlayer.z = camera.position.z;
                    myPlayer.rotation = camera.rotation.y;
                    
                    // Send position to server
                    socket.emit('move', {
                        x: myPlayer.x,
                        y: myPlayer.y,
                        z: myPlayer.z,
                        rotation: myPlayer.rotation
                    });
                }
                
                scene.render();
            });
            
            window.addEventListener("resize", function() {
                engine.resize();
            });
        }
        
        // Function to create the museum environment
        function createMuseum(scene) {
            // Create low-poly materials with PS2-style textures
            const floorMaterial = new BABYLON.StandardMaterial("floorMaterial", scene);
            floorMaterial.diffuseColor = new BABYLON.Color3(0.25, 0.24, 0.26); // Dark gray for floor
            floorMaterial.specularColor = new BABYLON.Color3(0, 0, 0); // No specular
            
            const wallMaterial = new BABYLON.StandardMaterial("wallMaterial", scene);
            wallMaterial.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.9); // Off-white for walls
            wallMaterial.specularColor = new BABYLON.Color3(0, 0, 0); // No specular
            
            const damagedWallMaterial = new BABYLON.StandardMaterial("damagedWallMaterial", scene);
            damagedWallMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.75, 0.7); // Slightly brownish
            damagedWallMaterial.specularColor = new BABYLON.Color3(0, 0, 0); // No specular
            
            const debrisMaterial = new BABYLON.StandardMaterial("debrisMaterial", scene);
            debrisMaterial.diffuseColor = new BABYLON.Color3(0.55, 0.57, 0.59); // Gray for debris
            debrisMaterial.specularColor = new BABYLON.Color3(0, 0, 0); // No specular
            
            const frameMaterial = new BABYLON.StandardMaterial("frameMaterial", scene);
            frameMaterial.diffuseColor = new BABYLON.Color3(0.4, 0.3, 0.2); // Brown for frames
            frameMaterial.specularColor = new BABYLON.Color3(0, 0, 0); // No specular
            
            const robotMaterial = new BABYLON.StandardMaterial("robotMaterial", scene);
            robotMaterial.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.65); // Metallic gray
            robotMaterial.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1); // Slight specular
            
            // Create main floor
            const floorSize = 50;
            const floor = BABYLON.MeshBuilder.CreateGround("floor", {
                width: floorSize,
                height: floorSize,
                subdivisions: 1
            }, scene);
            floor.material = floorMaterial;
            floor.checkCollisions = true;
            
            // Create outer walls (museum boundaries)
            const outerWallHeight = 5;
            const outerWalls = [
                // North wall
                BABYLON.MeshBuilder.CreateBox("northWall", {
                    width: floorSize,
                    height: outerWallHeight,
                    depth: 0.3
                }, scene),
                // South wall
                BABYLON.MeshBuilder.CreateBox("southWall", {
                    width: floorSize,
                    height: outerWallHeight,
                    depth: 0.3
                }, scene),
                // East wall
                BABYLON.MeshBuilder.CreateBox("eastWall", {
                    width: 0.3,
                    height: outerWallHeight,
                    depth: floorSize
                }, scene),
                // West wall
                BABYLON.MeshBuilder.CreateBox("westWall", {
                    width: 0.3,
                    height: outerWallHeight,
                    depth: floorSize
                }, scene)
            ];
            
            // Position the outer walls
            outerWalls[0].position = new BABYLON.Vector3(0, outerWallHeight / 2, floorSize / 2);
            outerWalls[1].position = new BABYLON.Vector3(0, outerWallHeight / 2, -floorSize / 2);
            outerWalls[2].position = new BABYLON.Vector3(floorSize / 2, outerWallHeight / 2, 0);
            outerWalls[3].position = new BABYLON.Vector3(-floorSize / 2, outerWallHeight / 2, 0);
            
            // Apply materials and collisions to outer walls
            outerWalls.forEach(wall => {
                wall.material = wallMaterial;
                wall.checkCollisions = true;
            });
            
            // Create maze-like interior walls
            createInteriorWalls(scene, wallMaterial, damagedWallMaterial);
            
            // Create ceiling
            const ceiling = BABYLON.MeshBuilder.CreateGround("ceiling", {
                width: floorSize,
                height: floorSize,
                subdivisions: 1
            }, scene);
            ceiling.position.y = outerWallHeight;
            ceiling.rotation = new BABYLON.Vector3(Math.PI, 0, 0);
            ceiling.material = wallMaterial;
            ceiling.checkCollisions = true;
            
            // Create broken ceiling sections
            createBrokenCeilings(scene, outerWallHeight, wallMaterial);
            
            // Add debris and fallen objects
            createDebris(scene, debrisMaterial);
            
            // Add picture frames
            createPictureFrames(scene, frameMaterial);
            
            // Add broken robot sculptures
            createRobotSculptures(scene, robotMaterial);
            
            // Add lighting
            createLighting(scene);
        }
        
        // Function to create interior walls for the maze-like layout
        function createInteriorWalls(scene, wallMaterial, damagedMaterial) {
            const wallHeight = 4;
            const wallThickness = 0.3;
            
            const wallPositions = [
                // Room 1
                { x: -15, z: 0, width: 15, rotation: 0, damaged: false },
                { x: -7.5, z: 7.5, width: 15, rotation: Math.PI / 2, damaged: true },
                
                // Room 2
                { x: 5, z: 10, width: 10, rotation: 0, damaged: false },
                { x: 10, z: 5, width: 10, rotation: Math.PI / 2, damaged: false },
                
                // Room 3
                { x: -5, z: -15, width: 10, rotation: Math.PI / 2, damaged: true },
                { x: -10, z: -10, width: 10, rotation: 0, damaged: false },
                
                // Room 4
                { x: 15, z: -5, width: 15, rotation: Math.PI / 2, damaged: false },
                { x: 7.5, z: -15, width: 15, rotation: 0, damaged: true },
                
                // Additional walls for maze complexity
                { x: -5, z: 5, width: 10, rotation: 0, damaged: true },
                { x: 5, z: -5, width: 10, rotation: Math.PI / 2, damaged: false },
                { x: 0, z: 15, width: 10, rotation: Math.PI / 2, damaged: false },
                { x: -15, z: -10, width: 10, rotation: Math.PI / 2, damaged: true }
            ];
            
            wallPositions.forEach((pos, index) => {
                // Determine if this wall should have a gap (doorway)
                const hasGap = index % 3 === 0;
                
                if (hasGap) {
                    // Create wall with a gap in the middle
                    const gapWidth = 2;
                    const segmentWidth = (pos.width - gapWidth) / 2;
                    
                    // Left segment
                    const leftWall = BABYLON.MeshBuilder.CreateBox(`wall_${index}_left`, {
                        width: segmentWidth,
                        height: wallHeight,
                        depth: wallThickness
                    }, scene);
                    
                    // Right segment
                    const rightWall = BABYLON.MeshBuilder.CreateBox(`wall_${index}_right`, {
                        width: segmentWidth,
                        height: wallHeight,
                        depth: wallThickness
                    }, scene);
                    
                    // Position the segments
                    if (pos.rotation === 0 || pos.rotation === Math.PI) {
                        leftWall.position = new BABYLON.Vector3(
                            pos.x - (pos.width / 4) - (gapWidth / 4),
                            wallHeight / 2,
                            pos.z
                        );
                        rightWall.position = new BABYLON.Vector3(
                            pos.x + (pos.width / 4) + (gapWidth / 4),
                            wallHeight / 2,
                            pos.z
                        );
                    } else {
                        leftWall.position = new BABYLON.Vector3(
                            pos.x,
                            wallHeight / 2,
                            pos.z - (pos.width / 4) - (gapWidth / 4)
                        );
                        rightWall.position = new BABYLON.Vector3(
                            pos.x,
                            wallHeight / 2,
                            pos.z + (pos.width / 4) + (gapWidth / 4)
                        );
                    }
                    
                    leftWall.rotation.y = pos.rotation;
                    rightWall.rotation.y = pos.rotation;
                    
                    // Apply material
                    leftWall.material = pos.damaged ? damagedMaterial : wallMaterial;
                    rightWall.material = pos.damaged ? damagedMaterial : wallMaterial;
                    
                    // Enable collisions
                    leftWall.checkCollisions = true;
                    rightWall.checkCollisions = true;
                } else {
                    // Create a full wall
                    const wall = BABYLON.MeshBuilder.CreateBox(`wall_${index}`, {
                        width: pos.width,
                        height: wallHeight,
                        depth: wallThickness
                    }, scene);
                    
                    // Position the wall
                    wall.position = new BABYLON.Vector3(pos.x, wallHeight / 2, pos.z);
                    wall.rotation.y = pos.rotation;
                    
                    // If this is a damaged wall, create holes and cracks
                    if (pos.damaged) {
                        // Create a hole in the wall
                        const holeSize = 1.5 + Math.random() * 1.5;
                        const holePosition = new BABYLON.Vector3(
                            Math.random() * (pos.width / 2) - (pos.width / 4),
                            Math.random() * 2 - 1,
                            0.2
                        );
                        
                        const hole = BABYLON.MeshBuilder.CreateSphere(`hole_${index}`, {
                            diameter: holeSize,
                            segments: 8
                        }, scene);
                        
                        hole.position = holePosition;
                        hole.parent = wall;
                        
                        // Use CSG to create the hole
                        const wallCSG = BABYLON.CSG.FromMesh(wall);
                        const holeCSG = BABYLON.CSG.FromMesh(hole);
                        const result = wallCSG.subtract(holeCSG);
                        
                        // Replace the original wall
                        wall.dispose();
                        hole.dispose();
                        
                        const newWall = result.toMesh(`damaged_wall_${index}`, damagedMaterial, scene);
                        newWall.checkCollisions = true;
                    } else {
                        wall.material = wallMaterial;
                        wall.checkCollisions = true;
                    }
                }
            });
        }
        
        // Function to create broken ceiling sections
        function createBrokenCeilings(scene, height, material) {
            const brokenPositions = [
                { x: -12, z: 8, size: 4 },
                { x: 10, z: -7, size: 5 },
                { x: -5, z: -12, size: 3 },
                { x: 14, z: 12, size: 4 }
            ];
            
            brokenPositions.forEach((pos, index) => {
                // Create a hole in the ceiling
                const hole = BABYLON.MeshBuilder.CreateBox(`ceiling_hole_${index}`, {
                    width: pos.size,
                    height: 0.1,
                    depth: pos.size
                }, scene);
                
                hole.position = new BABYLON.Vector3(pos.x, height - 0.1, pos.z);
                hole.material = material;
                hole.checkCollisions = false;
                
                // Add some debris falling from the ceiling
                for (let i = 0; i < 3 + Math.random() * 5; i++) {
                    const debrisSize = 0.3 + Math.random() * 0.5;
                    const debrisHeight = Math.random() * 3;
                    
                    const debris = BABYLON.MeshBuilder.CreateBox(`ceiling_debris_${index}_${i}`, {
                        width: debrisSize,
                        height: debrisSize,
                        depth: debrisSize
                    }, scene);
                    
                    // Position within the hole radius
                    const offsetX = (Math.random() - 0.5) * pos.size * 0.8;
                    const offsetZ = (Math.random() - 0.5) * pos.size * 0.8;
                    
                    debris.position = new BABYLON.Vector3(
                        pos.x + offsetX,
                        height - debrisHeight,
                        pos.z + offsetZ
                    );
                    
                    // Rotate for more natural look
                    debris.rotation = new BABYLON.Vector3(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI,
                        Math.random() * Math.PI
                    );
                    
                    debris.material = material;
                    debris.checkCollisions = true;
                }
            });
        }
        
        // Function to create debris scattered around
        function createDebris(scene, material) {
            const debrisPositions = [];
            // Generate random debris positions
            for (let i = 0; i < 50; i++) {
                debrisPositions.push({
                    x: Math.random() * 40 - 20,
                    z: Math.random() * 40 - 20,
                    size: 0.2 + Math.random() * 0.8
                });
            }
            
            debrisPositions.forEach((pos, index) => {
                const debris = BABYLON.MeshBuilder.CreateBox(`debris_${index}`, {
                    width: pos.size,
                    height: pos.size * 0.5,
                    depth: pos.size
                }, scene);
                
                debris.position = new BABYLON.Vector3(pos.x, pos.size * 0.25, pos.z);
                
                // Rotate for more natural look
                debris.rotation = new BABYLON.Vector3(
                    0,
                    Math.random() * Math.PI,
                    0
                );
                
                debris.material = material;
                debris.checkCollisions = true;
            });
        }
        
        // Function to create picture frames
        function createPictureFrames(scene, material) {
            // Wall-mounted frames
            const wallFramePositions = [
                { x: -15, z: -5, y: 2, rotation: Math.PI / 2, fallen: false },
                { x: 10, z: 10, y: 1.5, rotation: 0, fallen: false },
                { x: -5, z: 15, y: 2.5, rotation: Math.PI, fallen: false },
                { x: 5, z: -15, y: 1.8, rotation: 0, fallen: false }
            ];
            
            wallFramePositions.forEach((pos, index) => {
                const frameWidth = 1 + Math.random() * 0.5;
                const frameHeight = 1.5 + Math.random() * 0.5;
                const frameDepth = 0.1;
                
                const frame = BABYLON.MeshBuilder.CreateBox(`wall_frame_${index}`, {
                    width: frameWidth,
                    height: frameHeight,
                    depth: frameDepth
                }, scene);
                
                if (pos.fallen) {
                    // Place on the floor with random rotation
                    frame.position = new BABYLON.Vector3(
                        pos.x + (Math.random() - 0.5) * 2,
                        frameHeight / 2,
                        pos.z + (Math.random() - 0.5) * 2
                    );
                    
                    frame.rotation = new BABYLON.Vector3(
                        Math.PI / 2 + (Math.random() - 0.5) * 0.3,
                        Math.random() * Math.PI * 2,
                        0
                    );
                } else {
                    // Hang on the wall
                    const wallOffset = 0.2;
                    
                    if (pos.rotation === 0 || pos.rotation === Math.PI) {
                        frame.position = new BABYLON.Vector3(
                            pos.x,
                            pos.y,
                            pos.z + (pos.rotation === 0 ? -wallOffset : wallOffset)
                        );
                    } else {
                        frame.position = new BABYLON.Vector3(
                            pos.x + (pos.rotation === Math.PI / 2 ? -wallOffset : wallOffset),
                            pos.y,
                            pos.z
                        );
                    }
                    
                    frame.rotation.y = pos.rotation;
                    
                    // Add slight tilt for more realism
                    frame.rotation.z = (Math.random() - 0.5) * 0.2;
                }
                
                frame.material = material;
                frame.checkCollisions = true;
            });
            
            // Fallen frames on the floor
            const fallenFramePositions = [
                { x: -8, z: 0 },
                { x: 12, z: -5 },
                { x: 0, z: 10 },
                { x: -10, z: -8 },
                { x: 5, z: 5 }
            ];
            
            fallenFramePositions.forEach((pos, index) => {
                const frameWidth = 1 + Math.random() * 0.5;
                const frameHeight = 1.5 + Math.random() * 0.5;
                const frameDepth = 0.1;
                
                const frame = BABYLON.MeshBuilder.CreateBox(`fallen_frame_${index}`, {
                    width: frameWidth,
                    height: frameHeight,
                    depth: frameDepth
                }, scene);
                
                // Place on the floor
                frame.position = new BABYLON.Vector3(
                    pos.x + (Math.random() - 0.5) * 1,
                    frameHeight / 2,
                    pos.z + (Math.random() - 0.5) * 1
                );
                
                // Random rotation for fallen effect
                frame.rotation = new BABYLON.Vector3(
                    Math.PI / 2 + (Math.random() - 0.5) * 0.8,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 0.2
                );
                
                frame.material = material;
                frame.checkCollisions = true;
            });
        }
        
        // Function to create broken robot sculptures
        function createRobotSculptures(scene, material) {
            const robotPositions = [
                { x: -12, z: 10 },
                { x: 8, z: -12 },
                { x: 15, z: 8 },
                { x: -5, z: -8 }
            ];
            
            robotPositions.forEach((pos, index) => {
                // Create robot body parts
                const torso = BABYLON.MeshBuilder.CreateBox(`robot_${index}_torso`, {
                    width: 1,
                    height: 1.5,
                    depth: 0.6
                }, scene);
                
                const head = BABYLON.MeshBuilder.CreateSphere(`robot_${index}_head`, {
                    diameter: 0.7,
                    segments: 8
                }, scene);
                
                const limbs = [];
                
                // Create four limbs
                for (let i = 0; i < 4; i++) {
                    const limb = BABYLON.MeshBuilder.CreateCylinder(`robot_${index}_limb_${i}`, {
                        height: 1.2,
                        diameter: 0.2,
                        tessellation: 8
                    }, scene);
                    
                    limbs.push(limb);
                }
                
                // Position the parts in a broken, scattered formation
                torso.position = new BABYLON.Vector3(pos.x, 0.75, pos.z);
                torso.rotation = new BABYLON.Vector3(
                    Math.random() * Math.PI * 0.4,
                    Math.random() * Math.PI * 2,
                    Math.random() * Math.PI * 0.4
                );
                
                head.position = new BABYLON.Vector3(
                    pos.x + (Math.random() - 0.5) * 2,
                    0.35,
                    pos.z + (Math.random() - 0.5) * 2
                );
                
                limbs.forEach((limb, i) => {
                    limb.position = new BABYLON.Vector3(
                        pos.x + (Math.random() - 0.5) * 3,
                        0.3,
                        pos.z + (Math.random() - 0.5) * 3
                    );
                    
                    limb.rotation = new BABYLON.Vector3(
                        Math.random() * Math.PI,
                        Math.random() * Math.PI * 2,
                        Math.random() * Math.PI
                    );
                });
                
                // Apply materials
                torso.material = material;
                head.material = material;
                limbs.forEach(limb => limb.material = material);
                
                // Enable collisions for all parts
                torso.checkCollisions = true;
                head.checkCollisions = true;
                limbs.forEach(limb => limb.checkCollisions = true);
            });
        }
        
        // Function to create atmospheric lighting
        function createLighting(scene) {
            // Ambient light for base illumination
            const ambientLight = new BABYLON.HemisphericLight(
                "ambientLight",
                new BABYLON.Vector3(0, 1, 0),
                scene
            );
            ambientLight.intensity = 0.3;
            ambientLight.diffuse = new BABYLON.Color3(0.5, 0.5, 0.55);
            
            // Add point lights in various locations for atmospheric lighting
            const lightPositions = [
                { x: -10, y: 3, z: 8, intensity: 0.7 },
                { x: 10, y: 3, z: -5, intensity: 0.6 },
                { x: -5, y: 3, z: -12, intensity: 0.5 },
                { x: 15, y: 3, z: 10, intensity: 0.4 }
            ];
            
            lightPositions.forEach((pos, index) => {
                const light = new BABYLON.PointLight(
                    `pointLight_${index}`,
                    new BABYLON.Vector3(pos.x, pos.y, pos.z),
                    scene
                );
                
                light.intensity = pos.intensity;
                
                // Muted tones for PS2-era look
                light.diffuse = new BABYLON.Color3(0.9, 0.85, 0.8);
                light.specular = new BABYLON.Color3(0.1, 0.1, 0.1);
                
                // PS2-style limited shadow detail
                const shadowGenerator = new BABYLON.ShadowGenerator(512, light);
                shadowGenerator.usePoissonSampling = true;
                shadowGenerator.bias = 0.01;
                
                // Find meshes within range of this light
                const meshesInRange = scene.meshes.filter(mesh => {
                    const distance = BABYLON.Vector3.Distance(
                        mesh.position,
                        light.position
                    );
                    return distance < 15 && mesh.id !== "floor" && mesh.id !== "ceiling";
                });
                
                // Add meshes in range to shadow casters
                meshesInRange.forEach(mesh => {
                    shadowGenerator.addShadowCaster(mesh);
                });
                
                // Create a small glowing sphere for the light source
                const lightSphere = BABYLON.MeshBuilder.CreateSphere(`lightSphere_${index}`, {
                    diameter: 0.3,
                    segments: 8
                }, scene);
                
                lightSphere.position = light.position;
                
                // Self-illuminated material for the light source
                const lightMaterial = new BABYLON.StandardMaterial(`lightMaterial_${index}`, scene);
                lightMaterial.emissiveColor = new BABYLON.Color3(0.9, 0.8, 0.7);
                lightMaterial.disableLighting = true;
                
                lightSphere.material = lightMaterial;
            });
        }
        
        // Create player model (using primitive shapes as dummy characters)
        function createPlayerModel(id, playerData) {
            // Body (torso)
            const body = BABYLON.MeshBuilder.CreateCylinder(`body_${id}`, {
                diameterTop: 0.5,
                diameterBottom: 0.8,
                height: 1.5,
                tessellation: 6
            }, scene);
            body.position = new BABYLON.Vector3(playerData.x, playerData.y, playerData.z);
            body.rotation.y = playerData.rotation;
            
                        // Head
                        const head = BABYLON.MeshBuilder.CreateSphere(`head_${id}`, {
                diameter: 0.6
            }, scene);
            head.position = new BABYLON.Vector3(0, 0.9, 0);
            head.parent = body;
            
            // Color the player
            const color = new BABYLON.Color3(
                (playerData.color >> 16 & 255) / 255,
                (playerData.color >> 8 & 255) / 255,
                (playerData.color & 255) / 255
            );
            
            const bodyMat = new BABYLON.StandardMaterial(`bodyMat_${id}`, scene);
            bodyMat.diffuseColor = color;
            body.material = bodyMat;
            
            const headMat = new BABYLON.StandardMaterial(`headMat_${id}`, scene);
            headMat.diffuseColor = new BABYLON.Color3(0.9, 0.8, 0.7); // Skin color
            head.material = headMat;
            
            // Store reference
            players[id].mesh = body;
            
            // Health bar above player
            const healthBar = BABYLON.MeshBuilder.CreatePlane(`healthBar_${id}`, {
                width: 1,
                height: 0.2
            }, scene);
            healthBar.position = new BABYLON.Vector3(0, 2, 0);
            healthBar.parent = body;
            healthBar.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
            
            const healthBarMat = new BABYLON.StandardMaterial(`healthBarMat_${id}`, scene);
            healthBarMat.emissiveColor = new BABYLON.Color3(0, 1, 0); // Start green
            healthBar.material = healthBarMat;
            
            // Store health bar reference
            players[id].healthBar = healthBar;
            players[id].healthBarMat = healthBarMat;
            
            // Update health bar appearance
            updatePlayerHealthBar(id);
        }
        
        // Create a bullet
        function createBullet(bulletData) {
            const bullet = BABYLON.MeshBuilder.CreateSphere(`bullet_${bulletData.id}`, {
                diameter: 0.2
            }, scene);
            
            bullet.position = new BABYLON.Vector3(
                bulletData.x,
                bulletData.y,
                bulletData.z
            );
            
            bullet.direction = new BABYLON.Vector3(
                bulletData.dx,
                bulletData.dy,
                bulletData.dz
            ).normalize();
            
            bullet.speed = 0.5;
            bullet.playerId = bulletData.playerId;
            bullet.id = bulletData.id;
            
            // Color bullet based on player color
            const bulletMat = new BABYLON.StandardMaterial(`bulletMat_${bulletData.id}`, scene);
            if (players[bulletData.playerId]) {
                const color = new BABYLON.Color3(
                    (players[bulletData.playerId].color >> 16 & 255) / 255,
                    (players[bulletData.playerId].color >> 8 & 255) / 255,
                    (players[bulletData.playerId].color & 255) / 255
                );
                bulletMat.emissiveColor = color;
            } else {
                bulletMat.emissiveColor = BABYLON.Color3.White();
            }
            bullet.material = bulletMat;
            
            // Bullet movement and collision
            const bulletCheck = function() {
                if (bullet && !isGameOver) {
                    // Move bullet
                    bullet.position.addInPlace(bullet.direction.scale(bullet.speed));
                    
                    // Check for collisions with players
                    for (const id in players) {
                        if (id !== bullet.playerId && players[id].mesh && players[id].health > 0) {
                            if (bullet.intersectsMesh(players[id].mesh, false)) {
                                // Hit detected!
                                socket.emit('hit', {
                                    playerId: id,
                                    bulletId: bullet.id
                                });
                                return;
                            }
                        }
                    }
                    
                    // Check for out of bounds
                    if (Math.abs(bullet.position.x) > 25 || Math.abs(bullet.position.z) > 25) {
                        socket.emit('bulletRemoved', bullet.id);
                        return;
                    }
                    
                    // Check for collision with walls
                    const bulletRay = new BABYLON.Ray(
                        bullet.position,
                        bullet.direction,
                        0.2
                    );
                    
                    const hit = scene.pickWithRay(bulletRay, (mesh) => {
                        return mesh.checkCollisions && 
                               !mesh.name.includes("player") && 
                               !mesh.name.includes("bullet");
                    });
                    
                    if (hit && hit.pickedMesh) {
                        socket.emit('bulletRemoved', bullet.id);
                        return;
                    }
                    
                    // Continue checking
                    requestAnimationFrame(bulletCheck);
                }
            };
            
            bulletCheck();
            
            // Store reference
            bullets[bulletData.id].mesh = bullet;
        }
        
        // Create weapon
        function createWeapon() {
            // Gun barrel
            const barrel = BABYLON.MeshBuilder.CreateCylinder("barrel", {
                diameter: 0.1,
                height: 1
            }, scene);
            barrel.rotation.x = Math.PI / 2;
            barrel.position = new BABYLON.Vector3(0.3, -0.2, 0.5);
            
            // Gun body
            const body = BABYLON.MeshBuilder.CreateBox("gunBody", {
                width: 0.3,
                height: 0.2,
                depth: 0.8
            }, scene);
            body.position = new BABYLON.Vector3(0.3, -0.2, 0.2);
            
            // Combine into weapon
            const weapon = BABYLON.Mesh.MergeMeshes([barrel, body]);
            weapon.parent = camera;
            weapon.position = new BABYLON.Vector3(0.5, -0.3, 1);
            
            // Weapon material
            const weaponMat = new BABYLON.StandardMaterial("weaponMat", scene);
            weaponMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            weapon.material = weaponMat;
            
            // Shooting
            const canvas = document.getElementById("renderCanvas");
            canvas.addEventListener("click", () => {
                if (!isGameOver && document.pointerLockElement === canvas) {
                    const forward = camera.getForwardRay().direction.normalize();
                    
                    const bulletData = {
                        x: camera.position.x + forward.x * 0.5,
                        y: camera.position.y + forward.y * 0.5,
                        z: camera.position.z + forward.z * 0.5,
                        dx: forward.x,
                        dy: forward.y,
                        dz: forward.z
                    };
                    
                    socket.emit('shoot', bulletData);
                    
                    // Simple recoil animation
                    weapon.position.z += 0.1;
                    setTimeout(() => {
                        weapon.position.z -= 0.1;
                    }, 100);
                }
            });
        }
        
        // Start the game
        connectToServer();
    </script>
</body>
</html>